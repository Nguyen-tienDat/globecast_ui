// lib/services/user_specific_transcript_service.dart
import 'dart:async';
import 'dart:convert';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'whisper_service.dart';

/// Model for user-specific transcript entry
class UserTranscriptEntry {
  final String id;
  final String meetingId;
  final String speakerId;
  final String speakerName;
  final String originalText;
  final String originalLanguage;
  final String userLanguage;
  final String translatedText;
  final double confidence;
  final DateTime timestamp;
  final bool isFinal;
  final Map<String, dynamic> metadata;

  UserTranscriptEntry({
    required this.id,
    required this.meetingId,
    required this.speakerId,
    required this.speakerName,
    required this.originalText,
    required this.originalLanguage,
    required this.userLanguage,
    required this.translatedText,
    required this.confidence,
    required this.timestamp,
    required this.isFinal,
    this.metadata = const {},
  });

  factory UserTranscriptEntry.fromJson(Map<String, dynamic> json) {
    return UserTranscriptEntry(
      id: json['id'] ?? '',
      meetingId: json['meetingId'] ?? '',
      speakerId: json['speakerId'] ?? '',
      speakerName: json['speakerName'] ?? '',
      originalText: json['originalText'] ?? '',
      originalLanguage: json['originalLanguage'] ?? 'en',
      userLanguage: json['userLanguage'] ?? 'en',
      translatedText: json['translatedText'] ?? '',
      confidence: (json['confidence'] ?? 0.0).toDouble(),
      timestamp: DateTime.fromMillisecondsSinceEpoch(json['timestamp'] ?? 0),
      isFinal: json['isFinal'] ?? true,
      metadata: Map<String, dynamic>.from(json['metadata'] ?? {}),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'meetingId': meetingId,
      'speakerId': speakerId,
      'speakerName': speakerName,
      'originalText': originalText,
      'originalLanguage': originalLanguage,
      'userLanguage': userLanguage,
      'translatedText': translatedText,
      'confidence': confidence,
      'timestamp': timestamp.millisecondsSinceEpoch,
      'isFinal': isFinal,
      'metadata': metadata,
    };
  }

  @override
  String toString() {
    return 'UserTranscriptEntry($speakerName: "$translatedText" [$userLanguage])';
  }
}

/// Service qu·∫£n l√Ω transcript ri√™ng cho t·ª´ng user
class UserSpecificTranscriptService extends ChangeNotifier {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final WhisperService _whisperService;

  // User session info
  String? _userId;
  String? _meetingId;
  String? _userDisplayLanguage;

  // Transcript streams and caching
  final Map<String, List<UserTranscriptEntry>> _userTranscripts = {};
  final Map<String, StreamSubscription> _transcriptSubscriptions = {};
  final Map<String, StreamController<List<UserTranscriptEntry>>> _streamControllers = {};

  // Translation and processing
  final Map<String, String> _translationCache = {};
  Timer? _batchProcessingTimer;
  final List<TranscriptionResult> _pendingTranscriptions = [];

  // Statistics
  final Map<String, dynamic> _stats = {
    'totalTranscripts': 0,
    'totalTranslations': 0,
    'languagesSupported': 0,
    'activeUsers': 0,
  };

  UserSpecificTranscriptService(this._whisperService) {
    print('üéØ UserSpecificTranscriptService initialized');
    _setupWhisperListener();
    _startBatchProcessing();
  }

  // Getters
  String? get userId => _userId;
  String? get meetingId => _meetingId;
  String? get userDisplayLanguage => _userDisplayLanguage;
  Map<String, dynamic> get statistics => Map.unmodifiable(_stats);

  /// Initialize service cho user c·ª• th·ªÉ
  Future<bool> initializeForUser({
    required String userId,
    required String meetingId,
    required String displayLanguage,
  }) async {
    try {
      _userId = userId;
      _meetingId = meetingId;
      _userDisplayLanguage = displayLanguage;

      print('üéØ Initializing transcript service for user: $userId');
      print('üåç Display language: $displayLanguage');
      print('üì± Meeting: $meetingId');

      // T·∫°o stream controller cho user n√†y
      _streamControllers[userId] = StreamController<List<UserTranscriptEntry>>.broadcast();

      // Setup Firestore listener cho user n√†y
      await _setupUserTranscriptListener(userId, meetingId);

      _stats['activeUsers'] = (_stats['activeUsers'] ?? 0) + 1;
      notifyListeners();

      return true;
    } catch (e) {
      print('‚ùå Failed to initialize transcript service: $e');
      return false;
    }
  }

  /// Setup listener cho Whisper transcription results
  void _setupWhisperListener() {
    _whisperService.transcriptionStream.listen(
          (result) => _handleNewTranscription(result),
      onError: (error) => print('‚ùå Whisper transcription error: $error'),
    );
  }

  /// X·ª≠ l√Ω transcription m·ªõi t·ª´ Whisper
  void _handleNewTranscription(TranscriptionResult result) {
    if (_userId == null || _meetingId == null || _userDisplayLanguage == null) {
      return;
    }

    // Add to pending queue for batch processing
    _pendingTranscriptions.add(result);

    print('üìù Received transcription for processing: ${result.speakerName}');
    print('   Original: "${result.originalText}" (${result.originalLanguage})');
    print('   Target user language: $_userDisplayLanguage');
  }

  /// Batch processing transcriptions ƒë·ªÉ t·ªëi ∆∞u performance
  void _startBatchProcessing() {
    _batchProcessingTimer = Timer.periodic(const Duration(milliseconds: 500), (timer) {
      if (_pendingTranscriptions.isNotEmpty) {
        _processPendingTranscriptions();
      }
    });
  }

  /// X·ª≠ l√Ω batch transcriptions
  Future<void> _processPendingTranscriptions() async {
    if (_pendingTranscriptions.isEmpty || _userId == null) return;

    final batch = List<TranscriptionResult>.from(_pendingTranscriptions);
    _pendingTranscriptions.clear();

    print('üîÑ Processing batch of ${batch.length} transcriptions for user $_userId');

    for (final result in batch) {
      await _processTranscriptionForUser(result);
    }
  }

  /// X·ª≠ l√Ω m·ªôt transcription cho user c·ª• th·ªÉ
  Future<void> _processTranscriptionForUser(TranscriptionResult result) async {
    try {
      String finalText = result.translatedText;

      // N·∫øu ng√¥n ng·ªØ g·ªëc kh√°c v·ªõi ng√¥n ng·ªØ user mu·ªën th·∫•y, c·∫ßn translate
      if (result.targetLanguage != _userDisplayLanguage) {
        finalText = await _translateText(
          result.originalText,
          result.originalLanguage,
          _userDisplayLanguage!,
        );
      }

      // T·∫°o transcript entry cho user n√†y
      final entry = UserTranscriptEntry(
        id: '${result.speakerId}_${result.timestamp.millisecondsSinceEpoch}',
        meetingId: _meetingId!,
        speakerId: result.speakerId,
        speakerName: result.speakerName,
        originalText: result.originalText,
        originalLanguage: result.originalLanguage,
        userLanguage: _userDisplayLanguage!,
        translatedText: finalText,
        confidence: result.transcriptionConfidence,
        timestamp: result.timestamp,
        isFinal: result.isFinal,
        metadata: {
          'audioQuality': result.audioQuality,
          'processingTime': result.processingTime,
          'translationConfidence': result.translationConfidence,
        },
      );

      // L∆∞u v√†o Firestore cho user n√†y
      await _saveUserTranscript(entry);

      _stats['totalTranscripts'] = (_stats['totalTranscripts'] ?? 0) + 1;
      if (finalText != result.originalText) {
        _stats['totalTranslations'] = (_stats['totalTranslations'] ?? 0) + 1;
      }

      print('‚úÖ Processed transcript for ${result.speakerName} ‚Üí ${_userDisplayLanguage}: "$finalText"');

    } catch (e) {
      print('‚ùå Error processing transcription for user: $e');
    }
  }

  /// Translate text with caching
  Future<String> _translateText(String text, String fromLang, String toLang) async {
    if (fromLang == toLang) return text;

    final cacheKey = '${text.hashCode}_${fromLang}_$toLang';

    if (_translationCache.containsKey(cacheKey)) {
      return _translationCache[cacheKey]!;
    }

    try {
      // Use simple Google Translate API (you can enhance this)
      final translated = await _simpleTranslate(text, fromLang, toLang);

      // Cache the result
      if (_translationCache.length < 1000) {
        _translationCache[cacheKey] = translated;
      }

      return translated;
    } catch (e) {
      print('‚ùå Translation failed: $e');
      return text; // Fallback to original
    }
  }

  /// Simple translation implementation
  Future<String> _simpleTranslate(String text, String fromLang, String toLang) async {
    // Enhanced translation logic here
    // For demo purposes, using simple mapping

    final translations = {
      'Hello everyone!_en_vi': 'Xin ch√†o m·ªçi ng∆∞·ªùi!',
      'Hello everyone!_en_fr': 'Bonjour tout le monde!',
      'Hello everyone!_en_es': '¬°Hola a todos!',
      'Hello everyone!_en_de': 'Hallo zusammen!',
      'Hello everyone!_en_zh': 'Â§ßÂÆ∂Â•ΩÔºÅ',
      'Hello everyone!_en_ja': '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ',
      'Hello everyone!_en_ko': 'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!',

      'Xin ch√†o m·ªçi ng∆∞·ªùi!_vi_en': 'Hello everyone!',
      'Xin ch√†o m·ªçi ng∆∞·ªùi!_vi_fr': 'Bonjour tout le monde!',
      'Xin ch√†o m·ªçi ng∆∞·ªùi!_vi_es': '¬°Hola a todos!',
      'Xin ch√†o m·ªçi ng∆∞·ªùi!_vi_de': 'Hallo zusammen!',
      'Xin ch√†o m·ªçi ng∆∞·ªùi!_vi_zh': 'Â§ßÂÆ∂Â•ΩÔºÅ',
      'Xin ch√†o m·ªçi ng∆∞·ªùi!_vi_ja': '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ',
      'Xin ch√†o m·ªçi ng∆∞·ªùi!_vi_ko': 'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!',

      'Bonjour tout le monde!_fr_en': 'Hello everyone!',
      'Bonjour tout le monde!_fr_vi': 'Xin ch√†o m·ªçi ng∆∞·ªùi!',
      'Bonjour tout le monde!_fr_es': '¬°Hola a todos!',
      'Bonjour tout le monde!_fr_de': 'Hallo zusammen!',
      'Bonjour tout le monde!_fr_zh': 'Â§ßÂÆ∂Â•ΩÔºÅ',
      'Bonjour tout le monde!_fr_ja': '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ',
      'Bonjour tout le monde!_fr_ko': 'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!',

      '¬°Hola a todos!_es_en': 'Hello everyone!',
      '¬°Hola a todos!_es_vi': 'Xin ch√†o m·ªçi ng∆∞·ªùi!',
      '¬°Hola a todos!_es_fr': 'Bonjour tout le monde!',
      '¬°Hola a todos!_es_de': 'Hallo zusammen!',
      '¬°Hola a todos!_es_zh': 'Â§ßÂÆ∂Â•ΩÔºÅ',
      '¬°Hola a todos!_es_ja': '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ',
      '¬°Hola a todos!_es_ko': 'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!',

      'Hallo zusammen!_de_en': 'Hello everyone!',
      'Hallo zusammen!_de_vi': 'Xin ch√†o m·ªçi ng∆∞·ªùi!',
      'Hallo zusammen!_de_fr': 'Bonjour tout le monde!',
      'Hallo zusammen!_de_es': '¬°Hola a todos!',
      'Hallo zusammen!_de_zh': 'Â§ßÂÆ∂Â•ΩÔºÅ',
      'Hallo zusammen!_de_ja': '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ',
      'Hallo zusammen!_de_ko': 'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!',

      'Â§ßÂÆ∂Â•ΩÔºÅ_zh_en': 'Hello everyone!',
      'Â§ßÂÆ∂Â•ΩÔºÅ_zh_vi': 'Xin ch√†o m·ªçi ng∆∞·ªùi!',
      'Â§ßÂÆ∂Â•ΩÔºÅ_zh_fr': 'Bonjour tout le monde!',
      'Â§ßÂÆ∂Â•ΩÔºÅ_zh_es': '¬°Hola a todos!',
      'Â§ßÂÆ∂Â•ΩÔºÅ_zh_de': 'Hallo zusammen!',
      'Â§ßÂÆ∂Â•ΩÔºÅ_zh_ja': '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ',
      'Â§ßÂÆ∂Â•ΩÔºÅ_zh_ko': 'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!',

      '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ_ja_en': 'Hello everyone!',
      '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ_ja_vi': 'Xin ch√†o m·ªçi ng∆∞·ªùi!',
      '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ_ja_fr': 'Bonjour tout le monde!',
      '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ_ja_es': '¬°Hola a todos!',
      '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ_ja_de': 'Hallo zusammen!',
      '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ_ja_zh': 'Â§ßÂÆ∂Â•ΩÔºÅ',
      '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ_ja_ko': 'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!',

      'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!_ko_en': 'Hello everyone!',
      'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!_ko_vi': 'Xin ch√†o m·ªçi ng∆∞·ªùi!',
      'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!_ko_fr': 'Bonjour tout le monde!',
      'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!_ko_es': '¬°Hola a todos!',
      'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!_ko_de': 'Hallo zusammen!',
      'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!_ko_zh': 'Â§ßÂÆ∂Â•ΩÔºÅ',
      'ÏïàÎÖïÌïòÏÑ∏Ïöî Ïó¨Îü¨Î∂Ñ!_ko_ja': '„Åì„Çì„Å´„Å°„ÅØÁöÜ„Åï„ÇìÔºÅ',

      // Additional common phrases
      'How are you?_en_vi': 'B·∫°n kh·ªèe kh√¥ng?',
      'How are you?_en_fr': 'Comment allez-vous?',
      'How are you?_en_es': '¬øC√≥mo est√°s?',
      'How are you?_en_de': 'Wie geht es dir?',
      'How are you?_en_zh': '‰Ω†Â•ΩÂêóÔºü',
      'How are you?_en_ja': 'ÂÖÉÊ∞ó„Åß„Åô„ÅãÔºü',
      'How are you?_en_ko': 'Ïñ¥ÎñªÍ≤å ÏßÄÎÇ¥ÏÑ∏Ïöî?',

      'Thank you_en_vi': 'C·∫£m ∆°n',
      'Thank you_en_fr': 'Merci',
      'Thank you_en_es': 'Gracias',
      'Thank you_en_de': 'Danke',
      'Thank you_en_zh': 'Ë∞¢Ë∞¢',
      'Thank you_en_ja': '„ÅÇ„Çä„Åå„Å®„ÅÜ',
      'Thank you_en_ko': 'Í∞êÏÇ¨Ìï©ÎãàÎã§',

      'Good morning_en_vi': 'Ch√†o bu·ªïi s√°ng',
      'Good morning_en_fr': 'Bonjour',
      'Good morning_en_es': 'Buenos d√≠as',
      'Good morning_en_de': 'Guten Morgen',
      'Good morning_en_zh': 'Êó©‰∏äÂ•Ω',
      'Good morning_en_ja': '„Åä„ÅØ„Çà„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô',
      'Good morning_en_ko': 'Ï¢ãÏùÄ ÏïÑÏπ®',

      'See you later_en_vi': 'H·∫πn g·∫∑p l·∫°i',
      'See you later_en_fr': '√Ä bient√¥t',
      'See you later_en_es': 'Hasta luego',
      'See you later_en_de': 'Bis sp√§ter',
      'See you later_en_zh': 'ÂõûÂ§¥ËßÅ',
      'See you later_en_ja': '„Åæ„ÅüÂæå„Åß',
      'See you later_en_ko': 'ÎÇòÏ§ëÏóê Î¥êÏöî',
    };

    final key = '${text}_${fromLang}_$toLang';
    return translations[key] ?? text;
  }

  /// L∆∞u transcript v√†o Firestore theo user
  Future<void> _saveUserTranscript(UserTranscriptEntry entry) async {
    try {
      await _firestore
          .collection('meetings')
          .doc(_meetingId)
          .collection('user_transcripts')
          .doc(_userId)
          .collection('transcripts')
          .doc(entry.id)
          .set(entry.toJson());

      print('üíæ Saved transcript for user $_userId: ${entry.speakerName}');
    } catch (e) {
      print('‚ùå Failed to save user transcript: $e');
    }
  }

  /// Setup listener cho transcript c·ªßa user t·ª´ Firestore
  Future<void> _setupUserTranscriptListener(String userId, String meetingId) async {
    try {
      final subscription = _firestore
          .collection('meetings')
          .doc(meetingId)
          .collection('user_transcripts')
          .doc(userId)
          .collection('transcripts')
          .orderBy('timestamp')
          .snapshots()
          .listen((snapshot) {

        final transcripts = snapshot.docs.map((doc) {
          final data = doc.data();
          return UserTranscriptEntry.fromJson(data);
        }).toList();

        // Update local cache
        _userTranscripts[userId] = transcripts;

        // Emit to stream
        _streamControllers[userId]?.add(transcripts);

        print('üì± Updated transcripts for user $userId: ${transcripts.length} entries');
      });

      _transcriptSubscriptions[userId] = subscription;
    } catch (e) {
      print('‚ùå Failed to setup transcript listener: $e');
    }
  }

  /// Get stream c·ªßa transcripts cho user hi·ªán t·∫°i
  Stream<List<UserTranscriptEntry>> getUserTranscriptStream() {
    if (_userId == null || !_streamControllers.containsKey(_userId)) {
      return Stream.empty();
    }
    return _streamControllers[_userId]!.stream;
  }

  /// Get cached transcripts cho user
  List<UserTranscriptEntry> getCachedTranscripts([String? userId]) {
    final targetUserId = userId ?? _userId;
    if (targetUserId == null) return [];
    return _userTranscripts[targetUserId] ?? [];
  }

  /// Change user's display language
  Future<void> updateUserLanguage(String newLanguage) async {
    if (_userId == null || _meetingId == null) return;

    try {
      print('üåç Updating user language from $_userDisplayLanguage to $newLanguage');

      _userDisplayLanguage = newLanguage;

      // Clear existing transcripts for this user (they need to be re-translated)
      await _clearUserTranscripts();

      // Re-process existing transcriptions with new language
      await _reprocessTranscriptsForNewLanguage();

      print('‚úÖ Language updated successfully to $newLanguage');
      notifyListeners();

    } catch (e) {
      print('‚ùå Failed to update user language: $e');
    }
  }

  /// Clear user's existing transcripts
  Future<void> _clearUserTranscripts() async {
    if (_userId == null || _meetingId == null) return;

    try {
      final batch = _firestore.batch();
      final transcripts = await _firestore
          .collection('meetings')
          .doc(_meetingId)
          .collection('user_transcripts')
          .doc(_userId)
          .collection('transcripts')
          .get();

      for (final doc in transcripts.docs) {
        batch.delete(doc.reference);
      }

      await batch.commit();

      // Clear local cache
      _userTranscripts[_userId!] = [];

      print('üßπ Cleared transcripts for user $_userId');
    } catch (e) {
      print('‚ùå Failed to clear user transcripts: $e');
    }
  }

  /// Re-process transcripts for new language
  Future<void> _reprocessTranscriptsForNewLanguage() async {
    // This would typically re-process from the original transcription data
    // For now, we'll wait for new transcriptions to come in
    print('üîÑ Will re-process future transcriptions with new language');
  }

  /// Get meeting statistics for user
  Future<Map<String, dynamic>> getMeetingStatsForUser() async {
    if (_userId == null || _meetingId == null) return {};

    try {
      final transcripts = getCachedTranscripts();

      final speakers = <String>{};
      final languages = <String>{};
      double totalConfidence = 0;

      for (final transcript in transcripts) {
        speakers.add(transcript.speakerName);
        languages.add(transcript.originalLanguage);
        totalConfidence += transcript.confidence;
      }

      return {
        'userLanguage': _userDisplayLanguage,
        'totalTranscripts': transcripts.length,
        'uniqueSpeakers': speakers.length,
        'languagesHeard': languages.length,
        'averageConfidence': transcripts.isNotEmpty ? totalConfidence / transcripts.length : 0.0,
        'speakers': speakers.toList(),
        'languages': languages.toList(),
      };
    } catch (e) {
      print('‚ùå Failed to get meeting stats: $e');
      return {};
    }
  }

  /// Export transcripts for user
  Future<String> exportTranscriptsAsText() async {
    final transcripts = getCachedTranscripts();

    if (transcripts.isEmpty) return 'No transcripts available.';

    final buffer = StringBuffer();
    buffer.writeln('Meeting Transcripts');
    buffer.writeln('Language: $_userDisplayLanguage');
    buffer.writeln('Generated: ${DateTime.now()}');
    buffer.writeln('=' * 50);
    buffer.writeln();

    for (final transcript in transcripts) {
      final time = '${transcript.timestamp.hour.toString().padLeft(2, '0')}:'
          '${transcript.timestamp.minute.toString().padLeft(2, '0')}:'
          '${transcript.timestamp.second.toString().padLeft(2, '0')}';

      buffer.writeln('[$time] ${transcript.speakerName}:');
      buffer.writeln('${transcript.translatedText}');
      buffer.writeln();
    }

    return buffer.toString();
  }

  /// Clean up resources
  @override
  Future<void> dispose() async {
    print('üßπ Disposing UserSpecificTranscriptService...');

    _batchProcessingTimer?.cancel();

    // Cancel all subscriptions
    for (final subscription in _transcriptSubscriptions.values) {
      await subscription.cancel();
    }
    _transcriptSubscriptions.clear();

    // Close stream controllers
    for (final controller in _streamControllers.values) {
      await controller.close();
    }
    _streamControllers.clear();

    // Clear caches
    _userTranscripts.clear();
    _translationCache.clear();
    _pendingTranscriptions.clear();

    if (_userId != null) {
      _stats['activeUsers'] = (_stats['activeUsers'] ?? 1) - 1;
    }

    super.dispose();
  }
}